package main

import (
	"fmt"
	crypt "github.com/mtps/protoc-gen-cryptids/crypt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"os"
	"regexp"
	"strings"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

var typeEString = (&crypt.EString{}).ProtoReflect().Descriptor()
var typeEBytes = (&crypt.EBytes{}).ProtoReflect().Descriptor()
var typeETimestamp = (&crypt.ETimestamp{}).ProtoReflect().Descriptor()
var typeEInt = (&crypt.EInt{}).ProtoReflect().Descriptor()
var typeEAny = (&crypt.EAny{}).ProtoReflect().Descriptor()

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	fmt.Fprintf(os.Stderr, "generating for %s\n", file.Desc.Path())

	var cryptJavaClass string
	if file.Proto.Options.JavaOuterClassname != nil {
		cryptJavaClass = *file.Proto.Options.JavaOuterClassname
	} else {
		cryptJavaClass = capitalize(string(file.Desc.Name()))
	}

	javaPackage := *file.Proto.Options.JavaPackage
	javaDirectory := strings.ReplaceAll(javaPackage, ".", "/")
	filename := javaDirectory + "/" + cryptJavaClass + "CryptKt.kt"

	fmt.Fprintf(os.Stderr, "javaDir:%s msgClass:%s javaPkg:%s filename:%s  goimportpath:%s\n", javaDirectory, cryptJavaClass, javaPackage, filename, file.GoImportPath)
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-cryptids")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", javaPackage)
	g.P()
	for _, message := range file.Messages {
		typeName := cryptJavaClass + "." + string(message.Desc.Name())
		fmt.Fprintf(os.Stderr, "typeName:%s\n", typeName)
		for _, field := range message.Fields {
			// Handle EStrings
			if field.Desc.Kind() == protoreflect.MessageKind {
				fieldTypeName := string(field.Desc.Message().FullName())
				fieldName := capitalize(snakeToCamel(string(field.Desc.Name())))
				switch fieldTypeName {
				case string(typeEString.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted string field %s\n", fieldName)
					emitEStringWrapper(g, fieldName, typeName)
					break

				case string(typeEBytes.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted bytes field %s\n", fieldName)
					emitEBytesWrapper(g, fieldName, typeName)
					break

				case string(typeETimestamp.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted timestamp field %s\n", fieldName)
					emitETimestampWrapper(g, fieldName, typeName)
					break

				case string(typeEInt.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted int field %s\n", fieldName)
					emitEIntWrapper(g, fieldName, typeName)
					break

				case string(typeEAny.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted anything field %s\n", fieldName)
					emitEAnyWrapper(g, fieldName, typeName)
					break
				}
			}
		}
	}
	fmt.Fprintf(os.Stderr, "writing file %s\n", filename)
	return g
}

func capitalize(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

var snakeCaseRx = regexp.MustCompile(`_([a-z])`)

func snakeToCamel(s string) string {
	return snakeCaseRx.ReplaceAllStringFunc(s, func(match string) string {
		return strings.ToUpper(match[1:])
	})
}

func emitEStringWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray): String =")
	g.P("    String(decryptionProvider(it.value.toByteArray()))")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(encryptionProvider: (ByteArray) -> ByteArray): String =")
	g.P("    String(encryptionProvider(it.value.toByteArray()))")
	g.P()
}

func emitEBytesWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray): ByteArray =")
	g.P("    decryptionProvider(it.value.toByteArray())")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(encryptionProvider: (ByteArray) -> ByteArray): ByteArray =")
	g.P("    encryptionProvider(it.value.toByteArray())")
	g.P()
}

func emitETimestampWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray): com.google.protobuf.Timestamp =")
	g.P("    com.google.protobuf.Timestamp.parse(decryptionProvider(it.value))")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(encryptionProvider: (ByteArray) -> ByteArray): String =")
	g.P("    String(encryptionProvider(it.value.toByteArray()))")
	g.P()
}

func emitEIntWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray): Int =")
	g.P("    Int.valueOf(parse(decryptionProvider(it.value)))")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(encryptionProvider: (ByteArray) -> ByteArray): String =")
	g.P("    String(encryptionProvider(it.value.toByteArray()))")
	g.P()
}

func emitEAnyWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray): com.google.protobuf.Any = ")
	g.P("    com.google.protobuf.Any.Unmarshal(decryptionProvider(it.value))")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(encryptionProvider: (ByteArray) -> ByteArray): String =")
	g.P("    String(encryptionProvider(it.value.toByteArray()))")
	g.P()
}
