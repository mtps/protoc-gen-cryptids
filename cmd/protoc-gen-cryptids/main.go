package main

import (
	"fmt"
	crypt "github.com/mtps/protoc-gen-cryptids/crypt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"os"
	"regexp"
	"strings"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		// Emit the driver for providers to hook into.
		generateCryptProvider(gen)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

var cryptProviderPkg = "com.github.mtps.protobuf.crypt"
var cryptProviderFile = strings.ReplaceAll(".", "/", cryptProviderPkg) + ".CryptProviderKt.kt"
var cryptProviderName = cryptProviderPkg + ".CryptProvider"

func generateCryptProvider(gen *protogen.Plugin) *protogen.GeneratedFile {
	g := gen.NewGeneratedFile(cryptProviderFile, protogen.GoImportPath(""))
	g.P("// Code generated by protoc-gen-cryptids. DO NOT EDIT.")
	g.P("package ", cryptProviderPkg)
	g.P()
	g.P("object CryptProvider {")
	g.P("    var enc: (ByteArray) -> ByteArray = { it }")
	g.P("    var dec: (ByteArray) -> ByteArray = { it }")
	g.P("    fun registerEnc(f: (ByteArray) -> ByteArray) { enc = f }")
	g.P("    fun registerDec(f: (ByteArray) -> ByteArray) { dec = f }")
	g.P("}")
	return g
}

var typeEString = (&crypt.EString{}).ProtoReflect().Descriptor()
var typeEBytes = (&crypt.EBytes{}).ProtoReflect().Descriptor()
var typeETimestamp = (&crypt.ETimestamp{}).ProtoReflect().Descriptor()
var typeEInt = (&crypt.EInt{}).ProtoReflect().Descriptor()
var typeEAny = (&crypt.EAny{}).ProtoReflect().Descriptor()

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	fmt.Fprintf(os.Stderr, "generating for %s\n", file.Desc.Path())

	var cryptJavaClass string
	if file.Proto.Options.JavaOuterClassname != nil {
		cryptJavaClass = *file.Proto.Options.JavaOuterClassname
	} else {
		cryptJavaClass = capitalize(string(file.Desc.Name()))
	}

	javaPackage := *file.Proto.Options.JavaPackage
	javaDirectory := strings.ReplaceAll(javaPackage, ".", "/")
	filename := javaDirectory + "/" + cryptJavaClass + "CryptKt.kt"

	fmt.Fprintf(os.Stderr, "javaDir:%s msgClass:%s javaPkg:%s filename:%s  goimportpath:%s\n", javaDirectory, cryptJavaClass, javaPackage, filename, file.GoImportPath)
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-cryptids")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", javaPackage)
	g.P()
	for _, message := range file.Messages {
		typeName := cryptJavaClass + "." + string(message.Desc.Name())
		fmt.Fprintf(os.Stderr, "typeName:%s\n", typeName)
		for _, field := range message.Fields {
			// Handle EStrings
			if field.Desc.Kind() == protoreflect.MessageKind {
				fieldTypeName := string(field.Desc.Message().FullName())
				fieldName := capitalize(snakeToCamel(string(field.Desc.Name())))
				switch fieldTypeName {
				case string(typeEString.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted string field %s\n", fieldName)
					emitEStringWrapper(g, fieldName, typeName)
					break

				case string(typeEBytes.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted bytes field %s\n", fieldName)
					emitEBytesWrapper(g, fieldName, typeName)
					break

				case string(typeETimestamp.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted timestamp field %s\n", fieldName)
					emitETimestampWrapper(g, fieldName, typeName)
					break

				case string(typeEInt.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted int field %s\n", fieldName)
					emitEIntWrapper(g, fieldName, typeName)
					break

				case string(typeEAny.FullName()):
					fmt.Fprintf(os.Stderr, "detected encrypted anything field %s\n", fieldName)
					emitEAnyWrapper(g, fieldName, typeName)
					break
				}
			}
		}
	}
	fmt.Fprintf(os.Stderr, "writing file %s\n", filename)
	return g
}

func capitalize(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

func uncapitalize(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}

var snakeCaseRx = regexp.MustCompile(`_([a-z])`)

func snakeToCamel(s string) string {
	return snakeCaseRx.ReplaceAllStringFunc(s, func(match string) string {
		return strings.ToUpper(match[1:])
	})
}

func emitEStringWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", capitalize(fieldName), "(decryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".dec): String =")
	g.P("    String(decryptionProvider(", uncapitalize(fieldName), ".value.toByteArray()))")
	g.P()
	g.P("fun ", typeName, ".Builder.set", capitalize(fieldName), "(value: String, encryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".enc): ", typeName, ".Builder =")
	g.P("    set", capitalize(fieldName), "(")
	g.P("        ", ktPackageFor(typeEString), ".newBuilder().setValue(")
	g.P("            com.google.protobuf.ByteString.copyFrom(encryptionProvider(value.toByteArray()))")
	g.P("        )")
	g.P("    )")
	g.P()
}

func emitEBytesWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", capitalize(fieldName), "(decryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".dec): ByteArray =")
	g.P("    decryptionProvider(", uncapitalize(fieldName), ".value.toByteArray())")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(value: ByteArray, encryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".enc): ", typeName, ".Builder =")
	g.P("    set", capitalize(fieldName), "(")
	g.P("        ", ktPackageFor(typeEBytes), ".newBuilder().setValue(")
	g.P("            com.google.protobuf.ByteString.copyFrom(encryptionProvider(value))")
	g.P("        )")
	g.P("    )")
	g.P()
}

func emitETimestampWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", capitalize(fieldName), "(decryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".dec): com.google.protobuf.Timestamp =")
	g.P("    com.google.protobuf.Timestamp.newBuilder().also { builder ->")
	g.P("        val bb = java.nio.ByteBuffer")
	g.P("            .wrap(decryptionProvider(encryptedDate.value.toByteArray()))")
	g.P("            .order(java.nio.ByteOrder.BIG_ENDIAN)")
	g.P("        builder.seconds = bb.long")
	g.P("        builder.nanos = bb.int")
	g.P("    }.build()")
	g.P()
	g.P("fun ", typeName, ".Builder.set", capitalize(fieldName), "(value: com.google.protobuf.Timestamp, encryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".enc): ", typeName, ".Builder =")
	g.P("    set", capitalize(fieldName), "(")
	g.P("        ", ktPackageFor(typeETimestamp), ".newBuilder().setValue(")
	g.P("            com.google.protobuf.ByteString.copyFrom(encryptionProvider(")
	g.P("                java.nio.ByteBuffer.allocate(Int.SIZE_BYTES + Long.SIZE_BYTES)")
	g.P("                    .putLong(value.seconds)")
	g.P("                    .putInt(value.nanos)")
	g.P("                    .array()")
	g.P("                )")
	g.P("            )")
	g.P("        )")
	g.P("    )")
	g.P()
}

func emitEIntWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".dec): Int =")
	g.P("    java.nio.ByteBuffer")
	g.P("        .wrap(decryptionProvider(", uncapitalize(fieldName), ".value.toByteArray()))")
	g.P("        .order(java.nio.ByteOrder.BIG_ENDIAN)")
	g.P("        .int")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(value: Int, encryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".enc): ", typeName, ".Builder =")
	g.P("    setEncryptedAge(")
	g.P("        ", ktPackageFor(typeEInt), ".newBuilder().setValue(")
	g.P("            com.google.protobuf.ByteString.copyFrom(")
	g.P("                encryptionProvider(java.nio.ByteBuffer")
	g.P("                    .allocate(Int.SIZE_BYTES)")
	g.P("                    .putInt(value)")
	g.P("                    .order(java.nio.ByteOrder.BIG_ENDIAN)")
	g.P("                    .array()")
	g.P("                )")
	g.P("            )")
	g.P("        )")
	g.P("    )")
	g.P()
}

func emitEAnyWrapper(g *protogen.GeneratedFile, fieldName string, typeName string) {
	g.P("fun ", typeName, ".decrypt", fieldName, "(decryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".dec): com.google.protobuf.Any = ")
	g.P("    com.google.protobuf.Any.parseFrom(decryptionProvider(encryptedSomething.value.toByteArray()))")
	g.P()
	g.P("fun ", typeName, ".Builder.set", fieldName, "(value: com.google.protobuf.Any, encryptionProvider: (ByteArray) -> ByteArray = ", cryptProviderName, ".enc): ", typeName, ".Builder =")
	g.P("    set", capitalize(fieldName), "(")
	g.P("        com.github.mtps.protobuf.crypt.CryptProto.EAny.newBuilder().setValue(")
	g.P("            com.google.protobuf.ByteString.copyFrom(encryptionProvider(value.toByteArray()))")
	g.P("        )")
	g.P("    )")
	g.P()
}

func ktPackageFor(descriptor protoreflect.Descriptor) string {
	return "com.github.mtps.protobuf.crypt.CryptProto." + string(descriptor.Name())
}
